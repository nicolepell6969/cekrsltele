// === CRYPTO SHIM (untuk Baileys) ===
(() => {
  try {
    const nodeCrypto = require('node:crypto');
    if (!globalThis.crypto) globalThis.crypto = nodeCrypto.webcrypto || nodeCrypto;
  } catch {
    try {
      const c = require('crypto');
      if (!globalThis.crypto) globalThis.crypto = c;
    } catch {}
// [FIX] stray closing brace
// [FIX] stray })();
require('dotenv').config({ path: __dirname + '/.env' });

const fs = require('fs');
const path = require('path');
const TelegramBot = require('node-telegram-bot-api');
const QR = require('qrcode');

let checkMetroStatus = null;
try { checkMetroStatus = require('./checkMetroStatus'); }
catch { console.error('WARN: checkMetroStatus.js tidak ditemukan'); }

let { buildCekCommandFromText } = (() => {
  try { return require('./textToCommand'); }
  catch { return { buildCekCommandFromText: (t)=>({cmd:null,list:[],note:'modul textToCommand.js tidak ada'}) }; }
// [FIX] stray })();

// === Admin store (persisten) ===
let adminStore = null;
try { adminStore = require('./adminStore'); adminStore.seedFromEnv?.(); }
catch {
  const FILE = path.join(__dirname,'admins.json');
  function _read(){ try{ if(!fs.existsSync(FILE)) return {admins:[]}; return JSON.parse(fs.readFileSync(FILE,'utf8')||'{"admins":[]}'); }catch{return{admins:[]}} }
  function _write(o){ try{ fs.writeFileSync(FILE, JSON.stringify(o,null,2)); }catch{} }
  function seedFromEnv(){ const ids=String(process.env.ADMIN_IDS||'').split(',').map(s=>s.trim()).filter(Boolean).map(x=>String(Number(x))).filter(Boolean); if(!ids.length) return; const o=_read(); const set=new Set((o.admins||[]).map(String)); ids.forEach(i=>set.add(i)); o.admins=[...set]; _write(o); }
  function listAdmins(){ return (_read().admins||[]).map(String); }
  function isAdmin(id){ return listAdmins().includes(String(id)); }
  function addAdmin(id){ const sid=String(Number(id)); if(!sid||sid==='NaN') throw new Error('ID tidak valid'); const o=_read(); const set=new Set((o.admins||[]).map(String)); set.add(sid); o.admins=[...set]; _write(o); return o.admins; }
  function removeAdmin(id){ const sid=String(Number(id)); const o=_read(); o.admins=(o.admins||[]).map(String).filter(x=>x!==sid); _write(o); return o.admins; }
  adminStore = { seedFromEnv, listAdmins, isAdmin, addAdmin, removeAdmin };
  adminStore.seedFromEnv();
// [FIX] stray closing brace

// === Telegram init ===
const token = process.env.TELEGRAM_BOT_TOKEN || '';
if (!token) { console.error('ERROR: TELEGRAM_BOT_TOKEN kosong di .env'); process.exit(1); }
const bot = new TelegramBot(token, { polling: { interval: 800, autoStart: true } });








const applySendSafe=require('./sendSafe');
try{applySendSafe(bot);}catch(e){console.error('WARN sendSafe:',e?.message||e)}
// === Force-safe long message sender ===
(function attachSafeSender(){
  try{
    const origSend = bot.sendMessage.bind(bot);

    function splitSmart(text, max=3900){
      const t = String(text ?? '');
      if (t.length <= max) return [t];

      // coba pecah di 


      const chunks = [];
      let rest = t;
      const push = (str)=>{ if (str && str.length) chunks.push(str); };

      function takeUntil(boundaryRegex){
        let out = '';
        while (rest.length){
          if (out.length + rest.length <= max){ out += rest; rest = ''; break; }
          // cari boundary terdekat sebelum max
          const slice = rest.slice(0, max - out.length);
          let cut = slice.search(boundaryRegex);
          if (cut === -1){ // tidak ketemu boundary; coba cari last newline/space
            const lastNl = slice.lastIndexOf('\n');
            const lastSp = slice.lastIndexOf(' ');
            cut = Math.max(lastNl, lastSp);
            if (cut <= 0) cut = slice.length; // terpaksa hard-cut
// [FIX] stray closing brace
          out += slice.slice(0, cut);
          rest = rest.slice(cut);
          break;
// [FIX] stray closing brace
        return out;
// [FIX] stray closing brace

      // strategi: ambil blok demi blok dengan preferensi 

      while (rest.length){
        let part = '';
        // 1) coba 


// [HOTFIX] stripped: // [HOTFIX] removed:         part = takeUntil(/

// [FIX] (?![sS])/); // dummy regex untuk masuk ke fallback
        if (part.length === 0) part = rest.slice(0, Math.min(max, rest.length)), rest = rest.slice(part.length);

        // kalau masih terlalu panjang, pecah lagi di 
// [FIX]  atau spasi
        if (part.length > max){
          let p = part.slice(0, max);
          const lastNl = p.lastIndexOf('\n');
          const lastSp = p.lastIndexOf(' ');
          const cut = Math.max(lastNl, lastSp, 0) || p.length;
          push(p.slice(0, cut));
          rest = part.slice(cut) + rest;
        } else {
          push(part);
// [FIX] stray closing brace
// [FIX] stray closing brace
      // bersihkan potongan kosong
      return chunks.map(c => c).filter(Boolean);
// [FIX] stray closing brace

    // expose helper opsional
    bot.sendLong = async (chatId, text, extra={}) => {
      const parts = splitSmart(text, 3900);
      let last;
      for (const p of parts){
        // hindari error parse_mode karena potongan tidak sinkron
        const safeExtra = { ...extra };
        if (safeExtra.parse_mode) delete safeExtra.parse_mode;
        last = await origSend(chatId, p, safeExtra);
// [FIX] stray closing brace
      return last;
    };

    // Monkey-patch: semua pemanggilan sendMessage lewat pemecah
    bot.sendMessage = async (chatId, text, extra={}) => {
      if (typeof text !== 'string') return origSend(chatId, text, extra);
      const parts = splitSmart(text, 3900);
      if (parts.length === 1){
        // kirim biasa (hapus parse_mode bila mendekati limit)
        const safeExtra = { ...extra };
        if (text.length > 3800 && safeExtra.parse_mode) delete safeExtra.parse_mode;
        return origSend(chatId, text, safeExtra);
// [FIX] stray closing brace
      let last;
      for (const p of parts){
        const safeExtra = { ...extra };
        if (safeExtra.parse_mode) delete safeExtra.parse_mode;
        last = await origSend(chatId, p, safeExtra);
// [FIX] stray closing brace
      return last;
    };
// [FIX] removed stray catch:   }catch(e){
// [FIX] stray-catch body:     console.error('WARN attachSafeSender:', e && e.message ? e.message : e);
// [FIX] stray-catch body: // [FIX] stray closing brace
// [FIX] stray-catch body: // [FIX] stray })();
// === Force-safe long message sender ===
(function attachSafeSender(){
  try{
    const origSend = bot.sendMessage.bind(bot);

    function splitSmart(text, max=3900){
      const t = String(text ?? '');
      if (t.length <= max) return [t];

      // coba pecah di 


      const chunks = [];
      let rest = t;
      const push = (str)=>{ if (str && str.length) chunks.push(str); };

      function takeUntil(boundaryRegex){
        let out = '';
        while (rest.length){
          if (out.length + rest.length <= max){ out += rest; rest = ''; break; }
          // cari boundary terdekat sebelum max
          const slice = rest.slice(0, max - out.length);
          let cut = slice.search(boundaryRegex);
          if (cut === -1){ // tidak ketemu boundary; coba cari last newline/space
            const lastNl = slice.lastIndexOf('\n');
            const lastSp = slice.lastIndexOf(' ');
            cut = Math.max(lastNl, lastSp);
            if (cut <= 0) cut = slice.length; // terpaksa hard-cut
// [FIX] stray closing brace
          out += slice.slice(0, cut);
          rest = rest.slice(cut);
          break;
// [FIX] stray closing brace
        return out;
// [FIX] stray closing brace

      // strategi: ambil blok demi blok dengan preferensi 

      while (rest.length){
        let part = '';
        // 1) coba 


// [HOTFIX] stripped: // [HOTFIX] removed:         part = takeUntil(/

// [FIX] (?![sS])/); // dummy regex untuk masuk ke fallback
        if (part.length === 0) part = rest.slice(0, Math.min(max, rest.length)), rest = rest.slice(part.length);

        // kalau masih terlalu panjang, pecah lagi di 
// [FIX]  atau spasi
        if (part.length > max){
          let p = part.slice(0, max);
          const lastNl = p.lastIndexOf('\n');
          const lastSp = p.lastIndexOf(' ');
          const cut = Math.max(lastNl, lastSp, 0) || p.length;
          push(p.slice(0, cut));
          rest = part.slice(cut) + rest;
        } else {
          push(part);
// [FIX] stray closing brace
// [FIX] stray closing brace
      // bersihkan potongan kosong
      return chunks.map(c => c).filter(Boolean);
// [FIX] stray closing brace

    // expose helper opsional
    bot.sendLong = async (chatId, text, extra={}) => {
      const parts = splitSmart(text, 3900);
      let last;
      for (const p of parts){
        // hindari error parse_mode karena potongan tidak sinkron
        const safeExtra = { ...extra };
        if (safeExtra.parse_mode) delete safeExtra.parse_mode;
        last = await origSend(chatId, p, safeExtra);
// [FIX] stray closing brace
      return last;
    };

    // Monkey-patch: semua pemanggilan sendMessage lewat pemecah
    bot.sendMessage = async (chatId, text, extra={}) => {
      if (typeof text !== 'string') return origSend(chatId, text, extra);
      const parts = splitSmart(text, 3900);
      if (parts.length === 1){
        // kirim biasa (hapus parse_mode bila mendekati limit)
        const safeExtra = { ...extra };
        if (text.length > 3800 && safeExtra.parse_mode) delete safeExtra.parse_mode;
        return origSend(chatId, text, safeExtra);
// [FIX] stray closing brace
      let last;
      for (const p of parts){
        const safeExtra = { ...extra };
        if (safeExtra.parse_mode) delete safeExtra.parse_mode;
        last = await origSend(chatId, p, safeExtra);
// [FIX] stray closing brace
      return last;
    };
// [FIX] removed stray catch:   }catch(e){
// [FIX] stray-catch body:     console.error('WARN attachSafeSender:', e && e.message ? e.message : e);
// [FIX] stray-catch body: // [FIX] stray closing brace
// [FIX] stray-catch body: // [FIX] stray })();
// === Force-safe long message sender ===
(function attachSafeSender(){
  try{
    const origSend = bot.sendMessage.bind(bot);

    function splitSmart(text, max=3900){
      const t = String(text ?? '');
      if (t.length <= max) return [t];

      // coba pecah di 


      const chunks = [];
      let rest = t;
      const push = (str)=>{ if (str && str.length) chunks.push(str); };

      function takeUntil(boundaryRegex){
        let out = '';
        while (rest.length){
          if (out.length + rest.length <= max){ out += rest; rest = ''; break; }
          // cari boundary terdekat sebelum max
          const slice = rest.slice(0, max - out.length);
          let cut = slice.search(boundaryRegex);
          if (cut === -1){ // tidak ketemu boundary; coba cari last newline/space
            const lastNl = slice.lastIndexOf('\n');
            const lastSp = slice.lastIndexOf(' ');
            cut = Math.max(lastNl, lastSp);
            if (cut <= 0) cut = slice.length; // terpaksa hard-cut
// [FIX] stray closing brace
          out += slice.slice(0, cut);
          rest = rest.slice(cut);
          break;
// [FIX] stray closing brace
        return out;
// [FIX] stray closing brace

      // strategi: ambil blok demi blok dengan preferensi 

      while (rest.length){
        let part = '';
        // 1) coba 


// [HOTFIX] stripped: // [HOTFIX] removed:         part = takeUntil(/

// [FIX] (?![sS])/); // dummy regex untuk masuk ke fallback
        if (part.length === 0) part = rest.slice(0, Math.min(max, rest.length)), rest = rest.slice(part.length);

        // kalau masih terlalu panjang, pecah lagi di 
// [FIX]  atau spasi
        if (part.length > max){
          let p = part.slice(0, max);
          const lastNl = p.lastIndexOf('\n');
          const lastSp = p.lastIndexOf(' ');
          const cut = Math.max(lastNl, lastSp, 0) || p.length;
          push(p.slice(0, cut));
          rest = part.slice(cut) + rest;
        } else {
          push(part);
// [FIX] stray closing brace
// [FIX] stray closing brace
      // bersihkan potongan kosong
      return chunks.map(c => c).filter(Boolean);
// [FIX] stray closing brace

    // expose helper opsional
    bot.sendLong = async (chatId, text, extra={}) => {
      const parts = splitSmart(text, 3900);
      let last;
      for (const p of parts){
        // hindari error parse_mode karena potongan tidak sinkron
        const safeExtra = { ...extra };
        if (safeExtra.parse_mode) delete safeExtra.parse_mode;
        last = await origSend(chatId, p, safeExtra);
// [FIX] stray closing brace
      return last;
    };

    // Monkey-patch: semua pemanggilan sendMessage lewat pemecah
    bot.sendMessage = async (chatId, text, extra={}) => {
      if (typeof text !== 'string') return origSend(chatId, text, extra);
      const parts = splitSmart(text, 3900);
      if (parts.length === 1){
        // kirim biasa (hapus parse_mode bila mendekati limit)
        const safeExtra = { ...extra };
        if (text.length > 3800 && safeExtra.parse_mode) delete safeExtra.parse_mode;
        return origSend(chatId, text, safeExtra);
// [FIX] stray closing brace
      let last;
      for (const p of parts){
        const safeExtra = { ...extra };
        if (safeExtra.parse_mode) delete safeExtra.parse_mode;
        last = await origSend(chatId, p, safeExtra);
// [FIX] stray closing brace
      return last;
    };
// [FIX] removed stray catch:   }catch(e){
// [FIX] stray-catch body:     console.error('WARN attachSafeSender:', e && e.message ? e.message : e);
// [FIX] stray-catch body: // [FIX] stray closing brace
// [FIX] stray-catch body: // [FIX] stray })();
/** kirim pesan panjang aman untuk Telegram (tanpa kirim .txt) */
async function sendLong(chatId, text, extra = {}) {
  const MAX = 3900; // <4096, beri buffer
  const t = String(text ?? '');
  if (t.length <= MAX) return bot.sendMessage(chatId, t, extra);

  const lines = t.split('\n');
  let buf = '';
  for (const line of lines) {
    const would = buf ? (buf + '\n' + line) : line;
    if (would.length > MAX) {
      await bot.sendMessage(chatId, buf, extra);
      buf = line;
    } else {
      buf = would;
// [FIX] stray closing brace
// [FIX] stray closing brace
  if (buf) await bot.sendMessage(chatId, buf, extra);
// [FIX] stray closing brace



// === Helper: kirim pesan ke semua admin dari ENV ADMIN_IDS atau adminStore ===
async function sendToAdmins(text, opts = {}) {
  try {
    let ids = [];
    try {
      if (adminStore?.listAdmins) ids = adminStore.listAdmins().map(String);
    } catch {}
    if (!ids.length) {
      ids = String(process.env.ADMIN_IDS || '')
        .split(',')
        .map(v => v.trim())
        .filter(Boolean);
// [FIX] stray closing brace
    // fallback: kirim ke chat terakhir yang memulai bot (jika ada) ‚Äî abaikan jika tidak ada.
    if (!ids.length && typeof lastChatId !== 'undefined' && lastChatId) {
      ids = [String(lastChatId)];
// [FIX] stray closing brace
    for (const id of ids) {
      try { await bot.sendMessage(id, text, opts); } catch {}
// [FIX] stray closing brace
  } catch {}
// [FIX] stray closing brace
bot.getMe().then(me=>console.log(`Telegram bot: @${me.username} (id:${me.id})`)).catch(e=>console.error('getMe error:', e?.message));
bot.on('polling_error', (err)=> console.error('polling_error:', err?.response?.body || err?.message || err));

// === WhatsApp (opsional) ===
let WA_ENABLED = (String(process.env.WA_ENABLED||'false').toLowerCase()==='true');
let waClient=null, makeWASocket, useMultiFileAuthState, fetchLatestBaileysVersion;
try { ({ default: makeWASocket, useMultiFileAuthState, fetchLatestBaileysVersion } = require('@whiskeysockets/baileys')); } catch {}

async function waStart(notifyChatId){
  if (!WA_ENABLED) return;
  if (waClient || !makeWASocket) return;
  const { state, saveCreds } = await useMultiFileAuthState(path.join(__dirname,'wa_auth'));
  let version = [2,3000,0]; try { ({ version } = await fetchLatestBaileysVersion()); } catch {}

  const sock = makeWASocket({ version, auth: state, printQRInTerminal:false, syncFullHistory:false, browser:['cekrsltele','Chrome','1.0'] });
  
// [FIX-BLOCK]   // === WA connection.update (QR sebagai foto dengan fallback ASCII) ===
// [FIX-BLOCK]             const buf = await QR.toBuffer(qr, { type: 'png', scale: 8, margin: 1 });
// [FIX-BLOCK]           await bot.sendPhoto(notifyChatId, buf, {
// [FIX-BLOCK]             caption: 'üì≤ Scan QR WhatsApp berikut (¬±60 detik). Jika kadaluarsa, kirim /wa_pair lagi.'
// [FIX-BLOCK]           });
// [FIX-BLOCK]         } catch (e) {
// [FIX-BLOCK]           try {
// [FIX-BLOCK]             const qrt = require('qrcode-terminal');
// [FIX-BLOCK]             let ascii = '';
// [FIX-BLOCK]             qrt.generate(qr, { small: true }, c => ascii = c);
// [FIX-BLOCK]             await bot.sendMessage(notifyChatId, 'QR WhatsApp (fallback ASCII):\n\n' + ascii);
// [FIX-BLOCK]           } catch (e2) {
// [FIX-BLOCK]             await bot.sendMessage(notifyChatId, 'Gagal membuat QR image: ' + (e && e.message ? e.message : e));
// [FIX-BLOCK]           }
// [FIX-BLOCK]         }
// [FIX-BLOCK]       })();
// [FIX-BLOCK]     }
// [FIX-BLOCK]     if (connection === 'open') {
// [FIX-BLOCK]       if (notifyChatId) bot.sendMessage(notifyChatId, '‚úÖ WhatsApp tersambung.');
// [FIX-BLOCK]     } else if (connection === 'close') {
// [FIX-BLOCK]       const reason = (lastDisconnect && lastDisconnect.error && lastDisconnect.error.message) || 'Terputus';
// [FIX-BLOCK]       if (notifyChatId) bot.sendMessage(notifyChatId, '‚ö†Ô∏è WhatsApp terputus: ' + reason);
// [FIX-BLOCK]       try { if (globalThis.waClient) globalThis.waClient = null; } catch {}
// [FIX-BLOCK]     }
// [FIX-BLOCK]   });
// [FIX-BLOCK] 
// [FIX-BLOCK] waClient = sock;
  sock.ev.on('creds.update', saveCreds);
          const end = Date.now();
        addHistory(ne, null, result, ne, start, end);
        return bot.sendMessage(chatId, `üïõChecked Time: ${new Date(end).toLocaleString('id-ID', { timeZone: 'Asia/Jakarta' })}\n\n${result}`);
// [FIX] removed lone catch(e)
        return bot.sendMessage(chatId, '‚ùå Gagal cek 1 NE: '+(e?.message||e));
// [FIX] stray closing brace
// [FIX] stray closing brace

    // 2 NE
    if (parts.length >= 2) {
      const ne1 = parts[0], ne2 = parts[1];
      await bot.sendMessage(chatId, `üîÑ ONCEK, DITUNGGU`);
      try {
        const start = Date.now();
        const r1 = await runWithTimeout(checkMetroStatus(ne1, ne2, { mode: 'normal' }), Number(process.env.CEK_TIMEOUT_MS || 180000));
        const r2 = await runWithTimeout(checkMetroStatus(ne2, ne1, { mode: 'normal' }), Number(process.env.CEK_TIMEOUT_MS || 180000));
        const end = Date.now();
        const combined = `${r1}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n${r2}`;
        addHistory(ne1, ne2, combined, `${ne1} ${ne2}`, start, end);
        return bot.sendMessage(chatId, `üïõChecked Time: ${new Date(end).toLocaleString('id-ID', { timeZone: 'Asia/Jakarta' })}\n\n${combined}`, {
          reply_markup: { inline_keyboard: [[{ text: 'üîÅ CEK ULANG', callback_data: `retry_last_${history.length-1}` }]] }
        });
// [FIX] removed lone catch(e)
        return bot.sendMessage(chatId, '‚ùå Gagal cek 2 sisi: '+(e?.message||e));
// [FIX] stray closing brace
// [FIX] stray closing brace

    // salah format
    return bot.sendMessage(chatId, '‚ùó Format: /cek <NE1> [NE2]');
// [FIX] stray closing brace

  // ===== /history =====
  if (low === '/history') {
    if (!history.length) return bot.sendMessage(chatId, '‚ùå Belum ada riwayat pengecekan.');
    return bot.sendMessage(chatId, 'üëâ Klik di bawah untuk cek ulang atau hapus riwayat:', {
      reply_markup: { inline_keyboard: createHistoryButtons() }
    });
// [FIX] stray closing brace

  // ===== Teks bebas -> parsing NE =====
  if (text) {
    const { cmd, list, note } = buildCekCommandFromText(text);
    if (list && list.length === 1) {
      const ne = list[0];
      return bot.sendMessage(chatId, `‚ÑπÔ∏è Hanya menemukan 1 NE dari teks.\nNE terdeteksi: ${ne}\n\nGunakan perintah ini:\n/cek ${ne}`, {
        reply_markup: { inline_keyboard: [[{ text: '‚ñ∂Ô∏è Jalankan sekarang', callback_data: `runcek1_${ne}` }]] }
      });
// [FIX] stray closing brace
    if (list && list.length >= 2) {
      const a = list[0], b = list.find(x=>x!==a) || list[1];
      return bot.sendMessage(chatId, `NE terdeteksi: ${list.join(', ')}\n\nGunakan perintah ini:\n/cek ${a} ${b}`, {
        reply_markup: { inline_keyboard: [[{ text: '‚ñ∂Ô∏è Jalankan sekarang', callback_data: `runcek_${a}_${b}` }]] }
      });
// [FIX] stray closing brace
// [FIX] stray closing brace

  // BUKAN perintah & bukan teks yang bisa diparse ‚Üí jangan spam warning
});

// ===== Callback (cek ulang, run now, hapus) =====
bot.on('callback_query', async (q)=>{
  const { data, message } = q;
  const chatId = message.chat.id;
  try {
    await bot.answerCallbackQuery(q.id);

    if (data.startsWith('runcek_')) {
      const [, ne1, ne2] = data.split('_');
      await bot.sendMessage(chatId, `üîÑ Checking: ${ne1} ‚Üî ${ne2}...`);
      const r1 = await runWithTimeout(checkMetroStatus(ne1, ne2, { mode: 'normal' }), Number(process.env.CEK_TIMEOUT_MS || 180000));
      const r2 = await runWithTimeout(checkMetroStatus(ne2, ne1, { mode: 'normal' }), Number(process.env.CEK_TIMEOUT_MS || 180000));
      const end = Date.now();
      return bot.sendMessage(chatId, `üïõChecked Time: ${new Date(end).toLocaleString('id-ID', { timeZone: 'Asia/Jakarta' })}\n\n${r1}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n${r2}`, {
        reply_markup: { inline_keyboard: [[{ text: 'üîÅ Cek ulang', callback_data: `runcek_${ne1}_${ne2}` }]] }
      });
// [FIX] stray closing brace

    if (data.startsWith('runcek1_')) {
      const ne = data.substring('runcek1_'.length);
      await bot.sendMessage(chatId, `üîÑ Checking: ${ne}...`);
      const result = await runWithTimeout(checkMetroStatus.checkSingleNE(ne), Number(process.env.CEK_TIMEOUT_MS || 120000));
      const end = Date.now();
      return bot.sendMessage(chatId, `üïõChecked Time: ${new Date(end).toLocaleString('id-ID', { timeZone: 'Asia/Jakarta' })}\n\n${result}`, {
        reply_markup: { inline_keyboard: [[{ text: 'üîÅ Cek ulang', callback_data: `runcek1_${ne}` }]] }
      });
// [FIX] stray closing brace

    if (data.startsWith('retry_')) {
      let index = null;
      if (data.startsWith('retry_last_')) index = parseInt(data.split('_').pop(), 10);
      else index = parseInt(data.split('_')[1], 10);
      const e = history[index];
      if (e) {
        if (!e.ne2) {
          await bot.sendMessage(chatId, `üîÑ Checking: ${e.ne1}...`);
          const result = await runWithTimeout(checkMetroStatus.checkSingleNE(e.ne1), Number(process.env.CEK_TIMEOUT_MS || 120000));
          const end = Date.now();
          return bot.sendMessage(chatId, `üïõChecked Time: ${new Date(end).toLocaleString('id-ID', { timeZone: 'Asia/Jakarta' })}\n\n${result}`, {
            reply_markup: { inline_keyboard: [[{ text: 'üîÅ Cek ulang', callback_data: `runcek1_${e.ne1}` }]] }
          });
        } else {
          await bot.sendMessage(chatId, `üîÑ Checking: ${e.ne1} ‚Üî ${e.ne2}...`);
          const r1 = await runWithTimeout(checkMetroStatus(e.ne1, e.ne2, { mode: 'normal' }), Number(process.env.CEK_TIMEOUT_MS || 180000));
          const r2 = await runWithTimeout(checkMetroStatus(e.ne2, e.ne1, { mode: 'normal' }), Number(process.env.CEK_TIMEOUT_MS || 180000));
          const end = Date.now();
          return bot.sendMessage(chatId, `üïõChecked Time: ${new Date(end).toLocaleString('id-ID', { timeZone: 'Asia/Jakarta' })}\n\n${r1}\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n${r2}`, {
            reply_markup: { inline_keyboard: [[{ text: 'üîÅ Cek ulang', callback_data: `runcek_${e.ne1}_${e.ne2}` }]] }
          });
// [FIX] stray closing brace
// [FIX] stray closing brace
// [FIX] stray closing brace

    if (data.startsWith('delete_')) {
      const index = parseInt(data.split('_')[1], 10);
      const e = history[index];
      if (e) {
        history.splice(index,1); saveHistory();
        return bot.sendMessage(chatId, `‚úÖ Riwayat ${e.ne1}${e.ne2?` ‚Üî ${e.ne2}`:''} dihapus.`);
// [FIX] stray closing brace
// [FIX] stray closing brace
// [FIX] removed stray catch:   } catch(err){
// [FIX] stray-catch body:     console.error('callback error:', err);
// [FIX] stray-catch body:     bot.answerCallbackQuery(q.id, { text: '‚ùå Terjadi kesalahan. Coba lagi!', show_alert: true }).catch(()=>{});
// [FIX] stray-catch body: // [FIX] stray closing brace
// [FIX] stray-catch body: });

// === OPTIONAL: kirim error penting ke admin pertama ===
function notifyAdmins(text){
  const admins = adminStore.listAdmins();
  const target = admins[0];
  if (target) bot.sendMessage(Number(target), text).catch(()=>{});
// [FIX] stray closing brace
process.on('unhandledRejection', err=> notifyAdmins('‚ö†Ô∏è unhandledRejection: '+(err?.message||err)));
process.on('uncaughtException', err=> { notifyAdmins('‚ö†Ô∏è uncaughtException: '+(err?.message||err)); setTimeout(()=>process.exit(1), 500); });


// === global error handlers: kirim error ke admin & exit agar systemd restart ===
process.on('unhandledRejection', async (err) => {
  try { await sendToAdmins('‚ùó *UnhandledRejection*\n' + (err?.stack || err)); } catch {}
  // tidak exit, biar lanjut jalan
});
process.on('uncaughtException', async (err) => {
  try { await sendToAdmins('‚ùó *UncaughtException*\n' + (err?.stack || err)); } catch {}
  // exit biar systemd auto-restart
  setTimeout(() => process.exit(1), 500);
});
